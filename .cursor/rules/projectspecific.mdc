---
description: 
globs: 
alwaysApply: true
---
# Project-Specific Rules: Python Backend + React Frontend + AWS
## Local Development + Docker + AWS Deployment

---

## 🎯 **PROJECT PLANNING & ARCHITECTURE**

### Pre-Implementation Requirements
1. **Data Schema Definition**: Define complete database schema and relationships before coding
2. **File Structure Planning**: Establish module organization following Python backend + React frontend patterns
3. **Dependency Mapping**: Identify all Python packages, npm packages, and AWS services needed
4. **User Flow Design**: Create user flow diagrams for key features before implementation
5. **API Specification**: Document all API endpoints with OpenAPI/Swagger before coding
6. **Docker Strategy**: Plan containerization approach for both development and deployment
7. **AWS Architecture**: Define complete AWS deployment architecture (ECS/Fargate, RDS, S3)

### Architecture Decision Process
8. **Multiple Approaches**: Evaluate at least 2-3 implementation approaches within tech stack
9. **Scalability Planning**: Consider AWS scaling patterns and cost implications upfront
10. **Technology Rationale**: Document all technology choices and reasoning in ARCHITECTURE.md
11. **Testing Strategy**: Plan complete testing approach (pytest, Jest, integration, E2E)
12. **CI/CD Pipeline**: Define deployment process and automation requirements
13. **Environment Strategy**: Plan configuration for local, Docker, staging, production environments

---

## 🏗️ **TECH STACK STANDARDS**

### Framework Consistency
14. **Backend**: Python (Flask/FastAPI/Django) - maintain existing framework choice
15. **Frontend**: React with TypeScript preferred
16. **Database**: PostgreSQL for production, SQLite for quick local testing
17. **Deployment**: AWS ECS/Fargate with Docker containers
18. **Infrastructure**: AWS (EC2, RDS, S3, CloudFront as needed)

### Environment Strategy
19. **Local Primary**: Develop natively with local Python env and npm/yarn
20. **Docker Secondary**: Use for AWS deployment testing and demos
21. **AWS Target**: All code must deploy cleanly to AWS services

---

## 🐍 **PYTHON BACKEND RULES**

### Framework Consistency
22. **Maintain Current Framework**: Don't switch frameworks mid-project
23. **API Design**: RESTful APIs with consistent error handling
24. **Database Patterns**: Use existing ORM patterns (SQLAlchemy/Django ORM)
25. **Virtual Environment**: Always use venv/pipenv for local development
26. **Requirements Management**: Keep requirements.txt and requirements-dev.txt updated

### Python Code Standards
27. **Type Hints**: Use type hints for all function parameters and returns
28. **Error Handling**: Implement proper exception handling with structured logging
29. **Authentication**: Maintain existing JWT/session-based auth patterns
30. **API Validation**: Validate all incoming data with Pydantic or marshmallow
31. **Database Migrations**: Always create migrations for schema changes

### AWS Integration
32. **Environment Variables**: Use AWS Parameter Store or Secrets Manager
33. **Database**: AWS RDS PostgreSQL for production
34. **File Storage**: AWS S3 for static files and uploads
35. **Logging**: CloudWatch for centralized logging

---

## ⚛️ **REACT FRONTEND RULES**

### Component Architecture
36. **Functional Components**: Use functional components with hooks
37. **TypeScript**: Prefer TypeScript for type safety
38. **State Management**: Maintain existing state approach (Redux/Context/Zustand)
39. **Component Structure**: Keep components under 200 lines, extract custom hooks
40. **Props Interface**: Define clear TypeScript interfaces for all props

### Development Workflow
41. **Hot Reload**: Ensure hot reloading works in local environment
42. **Bundle Size**: Keep production bundles under reasonable limits
43. **Performance**: Use React.memo, useMemo, useCallback appropriately
44. **Error Boundaries**: Implement error boundaries for robust UX
45. **Testing**: Write tests for critical user flows

### Integration Patterns
46. **API Communication**: Use consistent API client (axios/fetch wrapper)
47. **Error Handling**: Implement global error handling for API calls
48. **Loading States**: Consistent loading and error UI patterns
49. **Authentication**: Integrate with backend auth seamlessly

---

## 🔄 **BACKEND-FRONTEND INTEGRATION**

### API Design
50. **Consistent Responses**: Standardized JSON response format
51. **Error Codes**: HTTP status codes with meaningful error messages
52. **CORS**: Properly configured CORS for local and production
53. **Documentation**: Maintain API documentation (OpenAPI/Swagger)

### Data Flow
54. **Validation**: Validate data on both frontend and backend
55. **Serialization**: Consistent data serialization patterns
56. **Real-time**: WebSocket/SSE patterns if needed
57. **Caching**: Implement appropriate caching strategies

---

## 🐳 **DOCKER & DEPLOYMENT**

### Docker Configuration
58. **Multi-stage Builds**: Separate build and runtime stages
59. **Environment Variables**: Use .env files for configuration
60. **Health Checks**: Implement proper health check endpoints
61. **Security**: Run containers as non-root user

### Local Docker Setup
62. **Docker Compose**: Use docker-compose for local multi-service setup
63. **Volume Mounts**: Mount source code for development
64. **Port Mapping**: Consistent port mapping (backend: 8000, frontend: 3000)
65. **Database**: Containerized PostgreSQL for Docker environment

### AWS Deployment
66. **ECR**: Push images to AWS Elastic Container Registry
67. **ECS/Fargate**: Deploy using AWS ECS with Fargate
68. **Load Balancer**: Application Load Balancer for HTTPS termination
69. **Auto Scaling**: Configure auto-scaling for production loads

---

## 🛡️ **SECURITY & ENVIRONMENT**

### Environment Management
70. **Local .env**: Use .env files for local configuration
71. **AWS Secrets**: Use AWS Secrets Manager for production secrets
72. **API Keys**: Never commit API keys to version control
73. **Database URLs**: Different database configs for each environment

### Security Implementation
74. **HTTPS Only**: Force HTTPS in production
75. **Input Sanitization**: Sanitize all user inputs
76. **SQL Injection**: Use parameterized queries only
77. **XSS Protection**: Implement CSP headers and input validation
78. **Rate Limiting**: Implement rate limiting on API endpoints

---

## 📊 **DATABASE & STORAGE**

### Database Strategy
79. **Local Development**: SQLite or local PostgreSQL
80. **Docker Environment**: Containerized PostgreSQL
81. **Production**: AWS RDS PostgreSQL
82. **Migrations**: Version-controlled database migrations
83. **Backups**: Automated backups in production

### File Handling
84. **Local Storage**: Local filesystem for development
85. **Production Storage**: AWS S3 for all file uploads
86. **CDN**: CloudFront for static asset delivery
87. **Image Processing**: Server-side image optimization

---

## 🧪 **TESTING & QUALITY**

### Testing Strategy
88. **Backend Tests**: Unit tests with pytest or unittest
89. **Frontend Tests**: Jest + React Testing Library
90. **Integration Tests**: API integration tests
91. **E2E Tests**: Cypress or Playwright for critical flows

### Code Quality
92. **Linting**: ESLint for React, flake8/black for Python
93. **Type Checking**: TypeScript for frontend, mypy for Python
94. **Code Coverage**: Maintain >80% coverage
95. **Pre-commit Hooks**: Run linting and tests before commits

---

## 🚀 **DEPLOYMENT WORKFLOW**

### Development Flow
96. **Local First**: Develop and test locally
97. **Docker Validation**: Test in Docker before deploying
98. **Staging**: Deploy to staging environment first
99. **Production**: Deploy to production after staging validation

### CI/CD Pipeline
100. **Build Process**: Automated building and testing
101. **Security Scanning**: Scan for vulnerabilities
102. **Performance Testing**: Basic performance checks
103. **Deployment Automation**: Automated deployment to AWS

---

## 📚 **DOCUMENTATION STANDARDS**

### Required Documentation
104. **README Updates**: Update README with architectural decisions and setup instructions
105. **API Documentation**: Maintain clear OpenAPI/Swagger documentation with examples
106. **Architecture Documentation**: Keep ARCHITECTURE.md current with technology decisions
107. **Configuration Guide**: Document setup requirements for all environments
108. **Troubleshooting Guide**: Include common issues and solutions for development setup
109. **Deployment Guide**: Document complete AWS deployment and configuration process

### Documentation Maintenance
110. **Living Documentation**: Update docs with every architectural change
111. **Code Examples**: Include working code examples in documentation
112. **Environment Setup**: Step-by-step setup instructions for new developers
113. **API Examples**: Request/response examples for all endpoints

---

## 🔧 **PROJECT-SPECIFIC COMMANDS**

### Local Development
```bash
# Backend
python -m venv venv
source venv/bin/activate  # or venv\Scripts\activate on Windows
pip install -r requirements-dev.txt
python manage.py runserver  # or uvicorn main:app --reload

# Frontend
npm install
npm start

# Database
python manage.py migrate  # Django
alembic upgrade head      # SQLAlchemy
```

### Docker Environment
```bash
# Full stack
docker-compose up --build

# Individual services
docker-compose up backend
docker-compose up frontend
```

### AWS Deployment
```bash
# Build and push
docker build -t your-app .
aws ecr get-login-password | docker login --username AWS --password-stdin
docker push your-ecr-url

# Deploy
aws ecs update-service --cluster your-cluster --service your-service --force-new-deployment
```

---

## 🎯 **PROJECT SUCCESS METRICS**

- **Planning phase completed before any implementation**
- **Complete architecture documented before coding**
- **Local development starts in <2 minutes**
- **Docker environment mirrors production exactly**
- **AWS deployment completes without manual configuration**
- **All environments use same codebase**
- **Zero secrets in version control**
- **Fast feedback loops maintained**
- **Documentation stays current with implementation**

---

*"This project is planned thoroughly, documented clearly, and deploys seamlessly from local → Docker → AWS with zero configuration drift"*