"""Security vulnerability scanner for Healthcare IVR Platform."""
import os
import sys
import json
from typing import Dict, List, Optional
import subprocess
import bandit
from bandit.core import manager
import safety
import requests
from datetime import datetime


class SecurityVulnerabilityScanner:
    """Comprehensive security vulnerability scanner."""

    def __init__(self, project_root: str):
        """Initialize scanner with project root directory."""
        self.project_root = project_root
        self.report_dir = os.path.join(project_root, "security_reports")
        os.makedirs(self.report_dir, exist_ok=True)

    def scan_python_code(self) -> Dict:
        """Scan Python code for security vulnerabilities using Bandit."""
        print("Running Python code security scan...")
        
        # Configure Bandit scan
        b_mgr = manager.BanditManager(
            config_file=None,
            agg_type='file',
            debug=False,
            verbose=True,
            quiet=False,
            profile=None,
            ignore_nosec=False
        )

        # Add target files
        b_mgr.discover_files([self.project_root], recursive=True)

        # Run scan
        b_mgr.run_tests()

        # Process results
        issues = []
        for issue in b_mgr.get_issue_list():
            issues.append({
                'filename': issue.fname,
                'test_name': issue.test_id,
                'issue_severity': issue.severity,
                'issue_confidence': issue.confidence,
                'issue_text': issue.text,
                'line_number': issue.lineno,
                'line_range': issue.linerange,
                'code': issue.get_code()
            })

        # Generate report
        report = {
            'scan_time': datetime.now().isoformat(),
            'total_files': len(b_mgr.files_list),
            'total_issues': len(issues),
            'issues_by_severity': {
                'HIGH': len([i for i in issues if i['issue_severity'] == 'HIGH']),
                'MEDIUM': len([i for i in issues if i['issue_severity'] == 'MEDIUM']),
                'LOW': len([i for i in issues if i['issue_severity'] == 'LOW'])
            },
            'issues': issues
        }

        # Save report
        report_path = os.path.join(
            self.report_dir,
            f"python_security_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        )
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)

        return report

    def check_dependencies(self) -> Dict:
        """Check Python dependencies for known vulnerabilities."""
        print("Checking dependencies for vulnerabilities...")
        
        requirements_path = os.path.join(self.project_root, 'requirements.txt')
        if not os.path.exists(requirements_path):
            return {
                'error': 'requirements.txt not found',
                'vulnerable_dependencies': []
            }

        try:
            # Run safety check
            vulns = safety.check(
                files=[requirements_path],
                ignore_ids=[],
                bare=True
            )

            # Process results
            vulnerable_deps = []
            for vuln in vulns:
                vulnerable_deps.append({
                    'package': vuln[0],
                    'installed_version': vuln[1],
                    'vulnerability_id': vuln[2],
                    'vulnerability_details': vuln[3],
                    'fixed_versions': vuln[4] if len(vuln) > 4 else None
                })

            report = {
                'scan_time': datetime.now().isoformat(),
                'total_vulnerabilities': len(vulnerable_deps),
                'vulnerable_dependencies': vulnerable_deps
            }

            # Save report
            report_path = os.path.join(
                self.report_dir,
                f"dependency_check_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            )
            with open(report_path, 'w') as f:
                json.dump(report, f, indent=2)

            return report

        except Exception as e:
            return {
                'error': str(e),
                'vulnerable_dependencies': []
            }

    def check_secrets(self) -> Dict:
        """Check for exposed secrets in code."""
        print("Checking for exposed secrets...")
        
        # Define patterns for sensitive information
        secret_patterns = [
            r'(?i)api[_-]key[_-]?\w*\s*[:=]\s*[\'"]\w+[\'"]',
            r'(?i)password[_-]?\w*\s*[:=]\s*[\'"]\w+[\'"]',
            r'(?i)secret[_-]?\w*\s*[:=]\s*[\'"]\w+[\'"]',
            r'(?i)token[_-]?\w*\s*[:=]\s*[\'"]\w+[\'"]',
            r'(?i)aws[_-]?\w*[_-]?key[_-]?\w*\s*[:=]\s*[\'"]\w+[\'"]',
            r'(?i)private[_-]?key[_-]?\w*\s*[:=]\s*[\'"]\w+[\'"]'
        ]

        findings = []
        for root, _, files in os.walk(self.project_root):
            for file in files:
                if file.endswith(('.py', '.env', '.yml', '.yaml', '.json')):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r') as f:
                            content = f.read()
                            for pattern in secret_patterns:
                                matches = re.findall(pattern, content)
                                if matches:
                                    findings.append({
                                        'file': file_path,
                                        'matches': matches,
                                        'pattern': pattern
                                    })
                    except Exception:
                        continue

        report = {
            'scan_time': datetime.now().isoformat(),
            'total_findings': len(findings),
            'findings': findings
        }

        # Save report
        report_path = os.path.join(
            self.report_dir,
            f"secrets_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        )
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)

        return report

    def check_ssl_tls_config(self) -> Dict:
        """Check SSL/TLS configuration in the codebase."""
        print("Checking SSL/TLS configuration...")
        
        findings = []
        
        # Check for insecure SSL/TLS configurations
        patterns = {
            'verify_disabled': r'verify\s*=\s*False',
            'ssl_verify_disabled': r'ssl_verify\s*=\s*False',
            'cert_verify_disabled': r'cert_verify\s*=\s*False',
            'weak_ciphers': r'SSLv2|SSLv3|TLSv1\.0|TLSv1\.1',
            'insecure_requests': r'urllib3\.disable_warnings|requests\.packages\.urllib3\.disable_warnings'
        }

        for root, _, files in os.walk(self.project_root):
            for file in files:
                if file.endswith('.py'):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r') as f:
                            content = f.read()
                            for check, pattern in patterns.items():
                                matches = re.findall(pattern, content)
                                if matches:
                                    findings.append({
                                        'file': file_path,
                                        'check': check,
                                        'matches': matches
                                    })
                    except Exception:
                        continue

        report = {
            'scan_time': datetime.now().isoformat(),
            'total_findings': len(findings),
            'findings': findings
        }

        # Save report
        report_path = os.path.join(
            self.report_dir,
            f"ssl_tls_check_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        )
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)

        return report

    def run_full_scan(self) -> Dict:
        """Run all security scans and generate a comprehensive report."""
        print("Starting comprehensive security scan...")
        
        # Run all scans
        code_scan = self.scan_python_code()
        dep_scan = self.check_dependencies()
        secrets_scan = self.check_secrets()
        ssl_scan = self.check_ssl_tls_config()

        # Compile comprehensive report
        report = {
            'scan_time': datetime.now().isoformat(),
            'project_root': self.project_root,
            'summary': {
                'total_code_issues': code_scan['total_issues'],
                'total_vulnerable_dependencies': dep_scan['total_vulnerabilities'],
                'total_secret_findings': secrets_scan['total_findings'],
                'total_ssl_findings': ssl_scan['total_findings']
            },
            'code_scan': code_scan,
            'dependency_scan': dep_scan,
            'secrets_scan': secrets_scan,
            'ssl_scan': ssl_scan
        }

        # Save comprehensive report
        report_path = os.path.join(
            self.report_dir,
            f"full_security_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        )
        with open(report_path, 'w') as f:
            json.dump(report, f, indent=2)

        return report


def main():
    """Run security scanner from command line."""
    if len(sys.argv) != 2:
        print("Usage: python vulnerability_scanner.py <project_root>")
        sys.exit(1)

    project_root = sys.argv[1]
    scanner = SecurityVulnerabilityScanner(project_root)
    report = scanner.run_full_scan()

    print("\nScan Summary:")
    print(f"Total code issues: {report['summary']['total_code_issues']}")
    print(f"Total vulnerable dependencies: {report['summary']['total_vulnerable_dependencies']}")
    print(f"Total secret findings: {report['summary']['total_secret_findings']}")
    print(f"Total SSL/TLS findings: {report['summary']['total_ssl_findings']}")
    print(f"\nDetailed reports saved in: {scanner.report_dir}")


if __name__ == '__main__':
    main() 